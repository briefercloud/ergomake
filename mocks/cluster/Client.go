// Code generated by mockery v2.26.1. DO NOT EDIT.

package mocks

import (
	appsv1 "k8s.io/api/apps/v1"
	batchv1 "k8s.io/api/batch/v1"

	cluster "github.com/ergomake/ergomake/internal/cluster"

	context "context"

	mock "github.com/stretchr/testify/mock"

	networkingv1 "k8s.io/api/networking/v1"

	v1 "k8s.io/api/core/v1"
)

// Client is an autogenerated mock type for the Client type
type Client struct {
	mock.Mock
}

type Client_Expecter struct {
	mock *mock.Mock
}

func (_m *Client) EXPECT() *Client_Expecter {
	return &Client_Expecter{mock: &_m.Mock}
}

// AreServicesAlive provides a mock function with given fields: ctx, namespace
func (_m *Client) AreServicesAlive(ctx context.Context, namespace string) (bool, error) {
	ret := _m.Called(ctx, namespace)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, namespace)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, namespace)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, namespace)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_AreServicesAlive_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AreServicesAlive'
type Client_AreServicesAlive_Call struct {
	*mock.Call
}

// AreServicesAlive is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
func (_e *Client_Expecter) AreServicesAlive(ctx interface{}, namespace interface{}) *Client_AreServicesAlive_Call {
	return &Client_AreServicesAlive_Call{Call: _e.mock.On("AreServicesAlive", ctx, namespace)}
}

func (_c *Client_AreServicesAlive_Call) Run(run func(ctx context.Context, namespace string)) *Client_AreServicesAlive_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Client_AreServicesAlive_Call) Return(_a0 bool, _a1 error) *Client_AreServicesAlive_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_AreServicesAlive_Call) RunAndReturn(run func(context.Context, string) (bool, error)) *Client_AreServicesAlive_Call {
	_c.Call.Return(run)
	return _c
}

// CreateConfigMap provides a mock function with given fields: ctx, configMap
func (_m *Client) CreateConfigMap(ctx context.Context, configMap *v1.ConfigMap) error {
	ret := _m.Called(ctx, configMap)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.ConfigMap) error); ok {
		r0 = rf(ctx, configMap)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_CreateConfigMap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateConfigMap'
type Client_CreateConfigMap_Call struct {
	*mock.Call
}

// CreateConfigMap is a helper method to define mock.On call
//   - ctx context.Context
//   - configMap *v1.ConfigMap
func (_e *Client_Expecter) CreateConfigMap(ctx interface{}, configMap interface{}) *Client_CreateConfigMap_Call {
	return &Client_CreateConfigMap_Call{Call: _e.mock.On("CreateConfigMap", ctx, configMap)}
}

func (_c *Client_CreateConfigMap_Call) Run(run func(ctx context.Context, configMap *v1.ConfigMap)) *Client_CreateConfigMap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*v1.ConfigMap))
	})
	return _c
}

func (_c *Client_CreateConfigMap_Call) Return(_a0 error) *Client_CreateConfigMap_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_CreateConfigMap_Call) RunAndReturn(run func(context.Context, *v1.ConfigMap) error) *Client_CreateConfigMap_Call {
	_c.Call.Return(run)
	return _c
}

// CreateDeployment provides a mock function with given fields: ctx, deployment
func (_m *Client) CreateDeployment(ctx context.Context, deployment *appsv1.Deployment) error {
	ret := _m.Called(ctx, deployment)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *appsv1.Deployment) error); ok {
		r0 = rf(ctx, deployment)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_CreateDeployment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateDeployment'
type Client_CreateDeployment_Call struct {
	*mock.Call
}

// CreateDeployment is a helper method to define mock.On call
//   - ctx context.Context
//   - deployment *appsv1.Deployment
func (_e *Client_Expecter) CreateDeployment(ctx interface{}, deployment interface{}) *Client_CreateDeployment_Call {
	return &Client_CreateDeployment_Call{Call: _e.mock.On("CreateDeployment", ctx, deployment)}
}

func (_c *Client_CreateDeployment_Call) Run(run func(ctx context.Context, deployment *appsv1.Deployment)) *Client_CreateDeployment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*appsv1.Deployment))
	})
	return _c
}

func (_c *Client_CreateDeployment_Call) Return(_a0 error) *Client_CreateDeployment_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_CreateDeployment_Call) RunAndReturn(run func(context.Context, *appsv1.Deployment) error) *Client_CreateDeployment_Call {
	_c.Call.Return(run)
	return _c
}

// CreateIngress provides a mock function with given fields: ctx, ingress
func (_m *Client) CreateIngress(ctx context.Context, ingress *networkingv1.Ingress) error {
	ret := _m.Called(ctx, ingress)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkingv1.Ingress) error); ok {
		r0 = rf(ctx, ingress)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_CreateIngress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateIngress'
type Client_CreateIngress_Call struct {
	*mock.Call
}

// CreateIngress is a helper method to define mock.On call
//   - ctx context.Context
//   - ingress *networkingv1.Ingress
func (_e *Client_Expecter) CreateIngress(ctx interface{}, ingress interface{}) *Client_CreateIngress_Call {
	return &Client_CreateIngress_Call{Call: _e.mock.On("CreateIngress", ctx, ingress)}
}

func (_c *Client_CreateIngress_Call) Run(run func(ctx context.Context, ingress *networkingv1.Ingress)) *Client_CreateIngress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*networkingv1.Ingress))
	})
	return _c
}

func (_c *Client_CreateIngress_Call) Return(_a0 error) *Client_CreateIngress_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_CreateIngress_Call) RunAndReturn(run func(context.Context, *networkingv1.Ingress) error) *Client_CreateIngress_Call {
	_c.Call.Return(run)
	return _c
}

// CreateJob provides a mock function with given fields: ctx, job
func (_m *Client) CreateJob(ctx context.Context, job *batchv1.Job) (*batchv1.Job, error) {
	ret := _m.Called(ctx, job)

	var r0 *batchv1.Job
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batchv1.Job) (*batchv1.Job, error)); ok {
		return rf(ctx, job)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batchv1.Job) *batchv1.Job); ok {
		r0 = rf(ctx, job)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*batchv1.Job)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batchv1.Job) error); ok {
		r1 = rf(ctx, job)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_CreateJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateJob'
type Client_CreateJob_Call struct {
	*mock.Call
}

// CreateJob is a helper method to define mock.On call
//   - ctx context.Context
//   - job *batchv1.Job
func (_e *Client_Expecter) CreateJob(ctx interface{}, job interface{}) *Client_CreateJob_Call {
	return &Client_CreateJob_Call{Call: _e.mock.On("CreateJob", ctx, job)}
}

func (_c *Client_CreateJob_Call) Run(run func(ctx context.Context, job *batchv1.Job)) *Client_CreateJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*batchv1.Job))
	})
	return _c
}

func (_c *Client_CreateJob_Call) Return(_a0 *batchv1.Job, _a1 error) *Client_CreateJob_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_CreateJob_Call) RunAndReturn(run func(context.Context, *batchv1.Job) (*batchv1.Job, error)) *Client_CreateJob_Call {
	_c.Call.Return(run)
	return _c
}

// CreateNamespace provides a mock function with given fields: ctx, namespace
func (_m *Client) CreateNamespace(ctx context.Context, namespace string) error {
	ret := _m.Called(ctx, namespace)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, namespace)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_CreateNamespace_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateNamespace'
type Client_CreateNamespace_Call struct {
	*mock.Call
}

// CreateNamespace is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
func (_e *Client_Expecter) CreateNamespace(ctx interface{}, namespace interface{}) *Client_CreateNamespace_Call {
	return &Client_CreateNamespace_Call{Call: _e.mock.On("CreateNamespace", ctx, namespace)}
}

func (_c *Client_CreateNamespace_Call) Run(run func(ctx context.Context, namespace string)) *Client_CreateNamespace_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Client_CreateNamespace_Call) Return(_a0 error) *Client_CreateNamespace_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_CreateNamespace_Call) RunAndReturn(run func(context.Context, string) error) *Client_CreateNamespace_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSecret provides a mock function with given fields: ctx, job
func (_m *Client) CreateSecret(ctx context.Context, job *v1.Secret) error {
	ret := _m.Called(ctx, job)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.Secret) error); ok {
		r0 = rf(ctx, job)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_CreateSecret_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSecret'
type Client_CreateSecret_Call struct {
	*mock.Call
}

// CreateSecret is a helper method to define mock.On call
//   - ctx context.Context
//   - job *v1.Secret
func (_e *Client_Expecter) CreateSecret(ctx interface{}, job interface{}) *Client_CreateSecret_Call {
	return &Client_CreateSecret_Call{Call: _e.mock.On("CreateSecret", ctx, job)}
}

func (_c *Client_CreateSecret_Call) Run(run func(ctx context.Context, job *v1.Secret)) *Client_CreateSecret_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*v1.Secret))
	})
	return _c
}

func (_c *Client_CreateSecret_Call) Return(_a0 error) *Client_CreateSecret_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_CreateSecret_Call) RunAndReturn(run func(context.Context, *v1.Secret) error) *Client_CreateSecret_Call {
	_c.Call.Return(run)
	return _c
}

// CreateService provides a mock function with given fields: ctx, service
func (_m *Client) CreateService(ctx context.Context, service *v1.Service) error {
	ret := _m.Called(ctx, service)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.Service) error); ok {
		r0 = rf(ctx, service)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_CreateService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateService'
type Client_CreateService_Call struct {
	*mock.Call
}

// CreateService is a helper method to define mock.On call
//   - ctx context.Context
//   - service *v1.Service
func (_e *Client_Expecter) CreateService(ctx interface{}, service interface{}) *Client_CreateService_Call {
	return &Client_CreateService_Call{Call: _e.mock.On("CreateService", ctx, service)}
}

func (_c *Client_CreateService_Call) Run(run func(ctx context.Context, service *v1.Service)) *Client_CreateService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*v1.Service))
	})
	return _c
}

func (_c *Client_CreateService_Call) Return(_a0 error) *Client_CreateService_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_CreateService_Call) RunAndReturn(run func(context.Context, *v1.Service) error) *Client_CreateService_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteNamespace provides a mock function with given fields: ctx, namespace
func (_m *Client) DeleteNamespace(ctx context.Context, namespace string) error {
	ret := _m.Called(ctx, namespace)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, namespace)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_DeleteNamespace_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteNamespace'
type Client_DeleteNamespace_Call struct {
	*mock.Call
}

// DeleteNamespace is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
func (_e *Client_Expecter) DeleteNamespace(ctx interface{}, namespace interface{}) *Client_DeleteNamespace_Call {
	return &Client_DeleteNamespace_Call{Call: _e.mock.On("DeleteNamespace", ctx, namespace)}
}

func (_c *Client_DeleteNamespace_Call) Run(run func(ctx context.Context, namespace string)) *Client_DeleteNamespace_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Client_DeleteNamespace_Call) Return(_a0 error) *Client_DeleteNamespace_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_DeleteNamespace_Call) RunAndReturn(run func(context.Context, string) error) *Client_DeleteNamespace_Call {
	_c.Call.Return(run)
	return _c
}

// GetDeployment provides a mock function with given fields: ctx, namespace, deploymentName
func (_m *Client) GetDeployment(ctx context.Context, namespace string, deploymentName string) (*appsv1.Deployment, error) {
	ret := _m.Called(ctx, namespace, deploymentName)

	var r0 *appsv1.Deployment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*appsv1.Deployment, error)); ok {
		return rf(ctx, namespace, deploymentName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *appsv1.Deployment); ok {
		r0 = rf(ctx, namespace, deploymentName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*appsv1.Deployment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, deploymentName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_GetDeployment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDeployment'
type Client_GetDeployment_Call struct {
	*mock.Call
}

// GetDeployment is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - deploymentName string
func (_e *Client_Expecter) GetDeployment(ctx interface{}, namespace interface{}, deploymentName interface{}) *Client_GetDeployment_Call {
	return &Client_GetDeployment_Call{Call: _e.mock.On("GetDeployment", ctx, namespace, deploymentName)}
}

func (_c *Client_GetDeployment_Call) Run(run func(ctx context.Context, namespace string, deploymentName string)) *Client_GetDeployment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *Client_GetDeployment_Call) Return(_a0 *appsv1.Deployment, _a1 error) *Client_GetDeployment_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_GetDeployment_Call) RunAndReturn(run func(context.Context, string, string) (*appsv1.Deployment, error)) *Client_GetDeployment_Call {
	_c.Call.Return(run)
	return _c
}

// GetIngress provides a mock function with given fields: ctx, namespace, name
func (_m *Client) GetIngress(ctx context.Context, namespace string, name string) (*networkingv1.Ingress, error) {
	ret := _m.Called(ctx, namespace, name)

	var r0 *networkingv1.Ingress
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*networkingv1.Ingress, error)); ok {
		return rf(ctx, namespace, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *networkingv1.Ingress); ok {
		r0 = rf(ctx, namespace, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkingv1.Ingress)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_GetIngress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIngress'
type Client_GetIngress_Call struct {
	*mock.Call
}

// GetIngress is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - name string
func (_e *Client_Expecter) GetIngress(ctx interface{}, namespace interface{}, name interface{}) *Client_GetIngress_Call {
	return &Client_GetIngress_Call{Call: _e.mock.On("GetIngress", ctx, namespace, name)}
}

func (_c *Client_GetIngress_Call) Run(run func(ctx context.Context, namespace string, name string)) *Client_GetIngress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *Client_GetIngress_Call) Return(_a0 *networkingv1.Ingress, _a1 error) *Client_GetIngress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_GetIngress_Call) RunAndReturn(run func(context.Context, string, string) (*networkingv1.Ingress, error)) *Client_GetIngress_Call {
	_c.Call.Return(run)
	return _c
}

// GetIngressUrl provides a mock function with given fields: ctx, namespace, serviceName, protocol
func (_m *Client) GetIngressUrl(ctx context.Context, namespace string, serviceName string, protocol string) (string, error) {
	ret := _m.Called(ctx, namespace, serviceName, protocol)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) (string, error)); ok {
		return rf(ctx, namespace, serviceName, protocol)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) string); ok {
		r0 = rf(ctx, namespace, serviceName, protocol)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, namespace, serviceName, protocol)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_GetIngressUrl_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIngressUrl'
type Client_GetIngressUrl_Call struct {
	*mock.Call
}

// GetIngressUrl is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - serviceName string
//   - protocol string
func (_e *Client_Expecter) GetIngressUrl(ctx interface{}, namespace interface{}, serviceName interface{}, protocol interface{}) *Client_GetIngressUrl_Call {
	return &Client_GetIngressUrl_Call{Call: _e.mock.On("GetIngressUrl", ctx, namespace, serviceName, protocol)}
}

func (_c *Client_GetIngressUrl_Call) Run(run func(ctx context.Context, namespace string, serviceName string, protocol string)) *Client_GetIngressUrl_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *Client_GetIngressUrl_Call) Return(_a0 string, _a1 error) *Client_GetIngressUrl_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_GetIngressUrl_Call) RunAndReturn(run func(context.Context, string, string, string) (string, error)) *Client_GetIngressUrl_Call {
	_c.Call.Return(run)
	return _c
}

// GetJobLogs provides a mock function with given fields: ctx, job, size
func (_m *Client) GetJobLogs(ctx context.Context, job *batchv1.Job, size int64) (string, error) {
	ret := _m.Called(ctx, job, size)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *batchv1.Job, int64) (string, error)); ok {
		return rf(ctx, job, size)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *batchv1.Job, int64) string); ok {
		r0 = rf(ctx, job, size)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *batchv1.Job, int64) error); ok {
		r1 = rf(ctx, job, size)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_GetJobLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJobLogs'
type Client_GetJobLogs_Call struct {
	*mock.Call
}

// GetJobLogs is a helper method to define mock.On call
//   - ctx context.Context
//   - job *batchv1.Job
//   - size int64
func (_e *Client_Expecter) GetJobLogs(ctx interface{}, job interface{}, size interface{}) *Client_GetJobLogs_Call {
	return &Client_GetJobLogs_Call{Call: _e.mock.On("GetJobLogs", ctx, job, size)}
}

func (_c *Client_GetJobLogs_Call) Run(run func(ctx context.Context, job *batchv1.Job, size int64)) *Client_GetJobLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*batchv1.Job), args[2].(int64))
	})
	return _c
}

func (_c *Client_GetJobLogs_Call) Return(_a0 string, _a1 error) *Client_GetJobLogs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_GetJobLogs_Call) RunAndReturn(run func(context.Context, *batchv1.Job, int64) (string, error)) *Client_GetJobLogs_Call {
	_c.Call.Return(run)
	return _c
}

// GetPreviewNamespaces provides a mock function with given fields: ctx
func (_m *Client) GetPreviewNamespaces(ctx context.Context) ([]v1.Namespace, error) {
	ret := _m.Called(ctx)

	var r0 []v1.Namespace
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]v1.Namespace, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []v1.Namespace); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]v1.Namespace)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_GetPreviewNamespaces_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPreviewNamespaces'
type Client_GetPreviewNamespaces_Call struct {
	*mock.Call
}

// GetPreviewNamespaces is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Client_Expecter) GetPreviewNamespaces(ctx interface{}) *Client_GetPreviewNamespaces_Call {
	return &Client_GetPreviewNamespaces_Call{Call: _e.mock.On("GetPreviewNamespaces", ctx)}
}

func (_c *Client_GetPreviewNamespaces_Call) Run(run func(ctx context.Context)) *Client_GetPreviewNamespaces_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Client_GetPreviewNamespaces_Call) Return(_a0 []v1.Namespace, _a1 error) *Client_GetPreviewNamespaces_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_GetPreviewNamespaces_Call) RunAndReturn(run func(context.Context) ([]v1.Namespace, error)) *Client_GetPreviewNamespaces_Call {
	_c.Call.Return(run)
	return _c
}

// ListJobs provides a mock function with given fields: ctx, namespace
func (_m *Client) ListJobs(ctx context.Context, namespace string) ([]*batchv1.Job, error) {
	ret := _m.Called(ctx, namespace)

	var r0 []*batchv1.Job
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*batchv1.Job, error)); ok {
		return rf(ctx, namespace)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*batchv1.Job); ok {
		r0 = rf(ctx, namespace)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*batchv1.Job)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, namespace)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_ListJobs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListJobs'
type Client_ListJobs_Call struct {
	*mock.Call
}

// ListJobs is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
func (_e *Client_Expecter) ListJobs(ctx interface{}, namespace interface{}) *Client_ListJobs_Call {
	return &Client_ListJobs_Call{Call: _e.mock.On("ListJobs", ctx, namespace)}
}

func (_c *Client_ListJobs_Call) Run(run func(ctx context.Context, namespace string)) *Client_ListJobs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Client_ListJobs_Call) Return(_a0 []*batchv1.Job, _a1 error) *Client_ListJobs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_ListJobs_Call) RunAndReturn(run func(context.Context, string) ([]*batchv1.Job, error)) *Client_ListJobs_Call {
	_c.Call.Return(run)
	return _c
}

// ScaleDeployment provides a mock function with given fields: ctx, namespace, deploymentName, replicas
func (_m *Client) ScaleDeployment(ctx context.Context, namespace string, deploymentName string, replicas int32) error {
	ret := _m.Called(ctx, namespace, deploymentName, replicas)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int32) error); ok {
		r0 = rf(ctx, namespace, deploymentName, replicas)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_ScaleDeployment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ScaleDeployment'
type Client_ScaleDeployment_Call struct {
	*mock.Call
}

// ScaleDeployment is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - deploymentName string
//   - replicas int32
func (_e *Client_Expecter) ScaleDeployment(ctx interface{}, namespace interface{}, deploymentName interface{}, replicas interface{}) *Client_ScaleDeployment_Call {
	return &Client_ScaleDeployment_Call{Call: _e.mock.On("ScaleDeployment", ctx, namespace, deploymentName, replicas)}
}

func (_c *Client_ScaleDeployment_Call) Run(run func(ctx context.Context, namespace string, deploymentName string, replicas int32)) *Client_ScaleDeployment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int32))
	})
	return _c
}

func (_c *Client_ScaleDeployment_Call) Return(_a0 error) *Client_ScaleDeployment_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_ScaleDeployment_Call) RunAndReturn(run func(context.Context, string, string, int32) error) *Client_ScaleDeployment_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateIngress provides a mock function with given fields: ctx, ingress
func (_m *Client) UpdateIngress(ctx context.Context, ingress *networkingv1.Ingress) error {
	ret := _m.Called(ctx, ingress)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *networkingv1.Ingress) error); ok {
		r0 = rf(ctx, ingress)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_UpdateIngress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateIngress'
type Client_UpdateIngress_Call struct {
	*mock.Call
}

// UpdateIngress is a helper method to define mock.On call
//   - ctx context.Context
//   - ingress *networkingv1.Ingress
func (_e *Client_Expecter) UpdateIngress(ctx interface{}, ingress interface{}) *Client_UpdateIngress_Call {
	return &Client_UpdateIngress_Call{Call: _e.mock.On("UpdateIngress", ctx, ingress)}
}

func (_c *Client_UpdateIngress_Call) Run(run func(ctx context.Context, ingress *networkingv1.Ingress)) *Client_UpdateIngress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*networkingv1.Ingress))
	})
	return _c
}

func (_c *Client_UpdateIngress_Call) Return(_a0 error) *Client_UpdateIngress_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_UpdateIngress_Call) RunAndReturn(run func(context.Context, *networkingv1.Ingress) error) *Client_UpdateIngress_Call {
	_c.Call.Return(run)
	return _c
}

// WaitDeployments provides a mock function with given fields: ctx, namespace
func (_m *Client) WaitDeployments(ctx context.Context, namespace string) error {
	ret := _m.Called(ctx, namespace)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, namespace)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_WaitDeployments_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WaitDeployments'
type Client_WaitDeployments_Call struct {
	*mock.Call
}

// WaitDeployments is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
func (_e *Client_Expecter) WaitDeployments(ctx interface{}, namespace interface{}) *Client_WaitDeployments_Call {
	return &Client_WaitDeployments_Call{Call: _e.mock.On("WaitDeployments", ctx, namespace)}
}

func (_c *Client_WaitDeployments_Call) Run(run func(ctx context.Context, namespace string)) *Client_WaitDeployments_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Client_WaitDeployments_Call) Return(_a0 error) *Client_WaitDeployments_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_WaitDeployments_Call) RunAndReturn(run func(context.Context, string) error) *Client_WaitDeployments_Call {
	_c.Call.Return(run)
	return _c
}

// WaitJobs provides a mock function with given fields: ctx, jobs
func (_m *Client) WaitJobs(ctx context.Context, jobs []*batchv1.Job) (*cluster.WaitJobsResult, error) {
	ret := _m.Called(ctx, jobs)

	var r0 *cluster.WaitJobsResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []*batchv1.Job) (*cluster.WaitJobsResult, error)); ok {
		return rf(ctx, jobs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*batchv1.Job) *cluster.WaitJobsResult); ok {
		r0 = rf(ctx, jobs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cluster.WaitJobsResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*batchv1.Job) error); ok {
		r1 = rf(ctx, jobs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_WaitJobs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WaitJobs'
type Client_WaitJobs_Call struct {
	*mock.Call
}

// WaitJobs is a helper method to define mock.On call
//   - ctx context.Context
//   - jobs []*batchv1.Job
func (_e *Client_Expecter) WaitJobs(ctx interface{}, jobs interface{}) *Client_WaitJobs_Call {
	return &Client_WaitJobs_Call{Call: _e.mock.On("WaitJobs", ctx, jobs)}
}

func (_c *Client_WaitJobs_Call) Run(run func(ctx context.Context, jobs []*batchv1.Job)) *Client_WaitJobs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*batchv1.Job))
	})
	return _c
}

func (_c *Client_WaitJobs_Call) Return(_a0 *cluster.WaitJobsResult, _a1 error) *Client_WaitJobs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_WaitJobs_Call) RunAndReturn(run func(context.Context, []*batchv1.Job) (*cluster.WaitJobsResult, error)) *Client_WaitJobs_Call {
	_c.Call.Return(run)
	return _c
}

// WatchServiceLogs provides a mock function with given fields: ctx, namespace, name, sinceSeconds
func (_m *Client) WatchServiceLogs(ctx context.Context, namespace string, name string, sinceSeconds int64) (<-chan string, <-chan error, error) {
	ret := _m.Called(ctx, namespace, name, sinceSeconds)

	var r0 <-chan string
	var r1 <-chan error
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64) (<-chan string, <-chan error, error)); ok {
		return rf(ctx, namespace, name, sinceSeconds)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64) <-chan string); ok {
		r0 = rf(ctx, namespace, name, sinceSeconds)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, int64) <-chan error); ok {
		r1 = rf(ctx, namespace, name, sinceSeconds)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(<-chan error)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, int64) error); ok {
		r2 = rf(ctx, namespace, name, sinceSeconds)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Client_WatchServiceLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchServiceLogs'
type Client_WatchServiceLogs_Call struct {
	*mock.Call
}

// WatchServiceLogs is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - name string
//   - sinceSeconds int64
func (_e *Client_Expecter) WatchServiceLogs(ctx interface{}, namespace interface{}, name interface{}, sinceSeconds interface{}) *Client_WatchServiceLogs_Call {
	return &Client_WatchServiceLogs_Call{Call: _e.mock.On("WatchServiceLogs", ctx, namespace, name, sinceSeconds)}
}

func (_c *Client_WatchServiceLogs_Call) Run(run func(ctx context.Context, namespace string, name string, sinceSeconds int64)) *Client_WatchServiceLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int64))
	})
	return _c
}

func (_c *Client_WatchServiceLogs_Call) Return(_a0 <-chan string, _a1 <-chan error, _a2 error) *Client_WatchServiceLogs_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Client_WatchServiceLogs_Call) RunAndReturn(run func(context.Context, string, string, int64) (<-chan string, <-chan error, error)) *Client_WatchServiceLogs_Call {
	_c.Call.Return(run)
	return _c
}

type mockConstructorTestingTNewClient interface {
	mock.TestingT
	Cleanup(func())
}

// NewClient creates a new instance of Client. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewClient(t mockConstructorTestingTNewClient) *Client {
	mock := &Client{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
